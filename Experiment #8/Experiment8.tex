% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% IEEE Style - Double columns, 11pt font, letterpaper
\documentclass[journal, twocolumn, final,11pt,letterpaper]{IEEEtran}	

% Include Latex Packages
\input{header.tex}


% Title of Document
\title{ECE385 Experiment \#8
	}
\author{
\IEEEauthorblockN{Eric Meyers, Ryan Helsdingen}\\
\IEEEauthorblockA{Section ABG; TAs: Ben Delay, Shuo Liu \\
March 30th, 2016 \\
emeyer7, helsdin2}}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
\begin{document}
	
%SECTION : Formatting and Title
\maketitle
\singlespacing

%SECTION 1 - Introduction - Eric
\section{Introduction}
The purpose of this lab is to introduce concepts pertaining to USB protocol/communication and VGA display. The main goal of this lab was to connect a USB keyboard to the Altera FPGA and allow a user to control a ball displayed on a VGA-connected monitor.

%SECTION 2 - Description of Circuit / Inputs and Outputs - 
\section{Description of Circuit}
RYAN SECTION

%SECTION 3 - Purpose of Modules - 
\section{Purpose of Modules}
RYAN SECTION

%SECTION 4 - Description of USB Protocol & Changes
\section{Description of USB Protocol \& Changes}
The USB protocol in Experiment 8 utilized the Cypress EZ-OTG (CY7C67200) USB controller on board the Altera. The CY7C67200 was used as a host controller and once a USB keyboard is plugged in, the keyboard acts as a device controller.\\

The USB Keyboard is not an interrupt-based device, rather the host must poll the keyboard and send requests to receive the scancode in return. For this, the team must write functions to perform input/output reading and writing. These functions must be used in conjunction with the system verilog hardware that is synthesized to retrieve data and write data. 

The two functions that were written by the team were in "usb.c" and "io\_handler.c" were pertaining to the reading and writing of data to and from the USB device controller (keyboard).\\

io\_handler.c:
\begin{itemize}
	\item 	void IO\_init(void)
	\item 	void IO\_write(alt\_u8 Address, alt\_u16 Data)
\end{itemize}


\begin{lstlisting}
void IO_write(alt_u8 Address, alt_u16 Data)
{
	*otg_hpi_address = Address;
	*otg_hpi_cs = 0;
	*otg_hpi_w = 0;
	*otg_hpi_data = Data;
	*otg_hpi_w = 1;
	*otg_hpi_cs = 1;
}
\end{lstlisting}
This function takes in parameters as the Address and Data to be written. It then sets the appropriate bits on the signal lines and sends the Data to the otg\_hpi\_data variable to be written to the usb hardware.\\ 

\begin{lstlisting}
alt_u16 IO_read(alt_u8 Address)
{
	alt_u16 temp;
	//printf("%x\n",temp);
	*otg_hpi_address = Address;
	*otg_hpi_cs = 0;
	*otg_hpi_r = 0;
	temp = *otg_hpi_data;
	*otg_hpi_r = 1;
	*otg_hpi_cs = 1;
	return temp;
}
\end{lstlisting}
This function performs similar actions to the IO\_write function in that it must read from a particular address on the USB hardware. The team had to use a temp variable to read it properly, set the appropriate signals, then send the data from otg\_hpi\_data into the temp variable which is then returned to the user by the function.\\

usb.c:
\begin{itemize}
	\item 	void UsbWrite(alt\_u16 Address, alt\_u16 Data)
	\item 	alt\_u16 UsbRead(alt\_u16 Address)
\end{itemize}
\begin{lstlisting}
void UsbWrite(alt_u16 Address, alt_u16 Data)
{
	IO_write(HPI_ADDR, Address);
	IO_write(HPI_DATA, Data);
}
\end{lstlisting}
This function utilizes the two functions written in the previous section (in io\_handler.c) and simply writes the particular address and the data in the parameters.


\begin{lstlisting}
alt_u16 UsbRead(alt_u16 Address)
{
	IO_write(HPI_ADDR, Address);
	alt_u16 temp = IO_read(HPI_DATA);
	return temp;
}
\end{lstlisting}
This function uses the two functions written in io\_handler.c to perform a read on the USB hardware. it first must write the address to HPI\_ADDR to receive the proper address, then the temp variable must store the result of IO\_read from HPI\_Data. 



%SECTION 5 - Schematic/Block Diagram - 
\section{Schematic/Block Diagram}
The Schematic / Block Diagrams for this lab can be found in the Figures section of this document ("Section XI: Figures"). The Top Level Module Diagram can be found in Figure \ref{fig:top-level}, the Ball Module Diagram can be found in Figure \ref{fig:ball}, the VGA Module Diagram can be found in Figure \ref{fig:vga}, and the Color Mapper Module can be found in Figure \ref{fig:color_mapper}.

%SECTION 6 - Post Lab - 
\section{Post Lab}
\begin{table}[htbp]
	\centering
	\begin{tabular}{c|c}	% ccccccc indicates 7 center aligned columns
		\toprule	% top separator
		Resource & Value \\
		\midrule
		LUT & 2663\\
		DSP & 10\\
		Memory (BRAM) & 82,944\\
		Flip-Flop & 646\\
		Frequency &   132.89 MHz\\
		Static Power & 102.09 mW\\
		Dynamic Power &  25.86 mW\\
		Total Power & 203.64 mW\\
		\bottomrule	% bottom separator
	\end{tabular}%	
	\caption{Design Statistics}
	\label{tab:design}
\end{table}

1. What is the difference between VGA\_clk and Clk? \\

\textit{Answer:}The VGA Clock runs at 25MHz to change how wide the individual pixels are, whereas the Clk onboard the processor runs at 50MHz (and does not affect the pixel size).\\

2. In the file io\_handler.h, why is it that the otg\_hpi\_address is defined as an integer pointer while the otg\_hpi\_r is defined as a char pointer? \\

\textit{Answer:} otg\_hpi\_r is a single bit and does not need to be declared as an int (16 bits - it would be a waste of space), whereas otg\_hpi\_address is multiple bits wide and must have multiple bits available to use.\\

3.What are the advantages and/or disadvantages of using a USB interface over PS/2 interface to connect to the keyboard? List any two. \\

\textit{Answer:} PS/2 keyboards aren't polled, but are completely interrupt based. This allows the processor to complete tasks while waiting. Drivers for PS/2 are much simpler than USB keyboard drivers. Another disadvantage is that the USB keyboard only takes in 6 keys every message, so this is limited compared to the PS/2. These are two disadvantages for using a USB keyboard over PS/2.\\

4.  Note that Ball\_Y\_Motion in the above statement may have been changed at the same clock edge that is causing the assignment of Ball\_Y\_pos.  Will the new value of Ball\_Y\_Motion be used, or the old?  How will this impact behavior of the ball during a bounce, and how might that interact with a response to a keypress?  Can you fix it?\\

\textit{Answer:} The new value of Ball\_Y\_Motion that would be used would be the old one and this would make it so that the ball bounces one clock cycle after the keypress is handled. A fix would be to put the assignment inside of the section of code that bounces the ball so that there is no delay in processing. \\

%SECTION 7 - Conclusion
\section{Conclusion}
RYAN SECTION

\clearpage
\onecolumn
%SECTION 11: Figures
\section{Figures}

\begin{figure} [H]
	\centering
	\includegraphics[scale=.5]{top_level_diagram.png}
	\caption{Lab 8 Top Level SV\label{fig:top-level}}
\end{figure}

\begin{figure} [H]
	\centering
	\includegraphics[scale=1]{ball_diagram.pdf}
	\caption{Ball Circuit Diagram\label{fig:ball}}
\end{figure}

\begin{figure} [H]
	\centering
	\includegraphics[scale=.5]{vga_diagram.png}
	\caption{VGA Circuit Diagram\label{fig:vga}}
\end{figure}

\begin{figure} [H]
	\centering
	\includegraphics[scale=.5]{color_mapper_diagram.png}
	\caption{Color Mapper Circuit Diagram\label{fig:color_mapper}}
\end{figure}            

     

\section*{Appendix}


\end{document}
