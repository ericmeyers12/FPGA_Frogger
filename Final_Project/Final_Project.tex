% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% IEEE Style - Double columns, 11pt font, letterpaper
\documentclass[journal, twocolumn, final,11pt,letterpaper]{IEEEtran}	

% Include Latex Packages
\input{header.tex}


% Title of Document
\title{ECE385 Final Project Report
	}
\author{
\IEEEauthorblockN{Frogger in System Verilog\\ Eric Meyers, Ryan Helsdingen}\\
\IEEEauthorblockA{Section ABG; TAs: Ben Delay, Shuo Liu \\
May 4th, 2016 \\
emeyer7, helsdin2}}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
\begin{document}
	
%SECTION : Formatting and Title
\maketitle
\singlespacing

%SECTION 1 - Introduction - ERIC
\section{Introduction}
For this project, we recreated the classic game called Frogger.  The basic premise of Frogger is to navigate three frogs through obstacles from the bottom to the top of the screen. Frogger must first pass through four lanes of traffic and a river full of lily pads in order to successfully make it to the other side of the map.  A frog may die by either colliding with a moving car or falling in the water. There are a total of three frogs that the user must navigate to the other end of the map, and once all three frogs move to their particular ending location, the user wins. If a user dies three times, then the game is over.\\

This system was developed in System Verilog in Quartus-II on an Altera-DE2-115 FPGA Board, and used software drivers developed in C to communicate with a USB keyboard (to be used as the controller).\\

To get a better understanding of what this project looks like once compiled and running on a FPGA board/VGA monitor, please refer to Figure \ref{fig:starting-screen}.

%SECTION 2 - List of Features
\section{List of Features}
	%RYAN SECTION
\begin{itemize}
	\item User controlled frog sprite moves according to grid set on VGA display
	\begin{itemize}
		\item Up, down, left, or right depending on keyboard input
		\item Frog position restricted to on-screen
		\item Frog direction held after keyboard direction inputed
		\item Frog contains collision algorithms for obstacles 
		\item A total of three frogs placed into game at three different starting points
		\begin{itemize}
			\item three endpoints for frogs to get to
			\item frog can finish at any endpoint but only one frog can finish per endpoint 
		\end{itemize} 
	\end{itemize}
	\item Generation of moving obstacles
	\begin{itemize}
		\item Four lanes of at most four cars in them 
		\begin{itemize}
				\item Each row moves at specific speed, direction
				\item Cars wrap around screen
				\item Frogger dies upon impact with car ending the game
		\end{itemize}
		\item Four lanes of at most four lilypads in them
		\begin{itemize}
			\item Each row moves at specific speed, direction
			\item Lily pads wrap around screen
			\item Frogger lives by stepping onto the lily pad, drowns by falling into the water
			\item If the lily pad moves off the screen with Frogger on it, Frogger will fall into the water
		\end{itemize}
	\end{itemize}
%	\item Multiple levels with increasing difficulty

	\item Working game clock at the top of the screen.
		\begin{itemize}
			\item 60 seconds to complete the level.
			\item Clock resets at the start of the game
			\item Game ends when the game clock runs out of time
		\end{itemize} 
	\item Color/VGA Monitor Output
	\begin{itemize}
		\item Detailed sprites give look and feel in graphical user interface
		\item Colors allow user to clearly differentiate between obstacle, user controlled frog, and the map background
	\end{itemize}
	\item Game reset button established that can reset the game at any point.
\end{itemize}

%\vspace{5mm}
%
%\textit{Optional Functionality and Complexity}
%\begin{itemize}
%	\item Multiple maps
%	\begin{itemize}
%		\item Maps taking place with different shaped obstacles and different background
%	\end{itemize}
%	\item Sound - 8-bit soundtrack
%	\item Sprites and animations
%	\item Start menu - Options Help Highscores, Start Button
%	\item Powerups:
%		\begin{itemize}
%			\item Slow-down/speed-up obstacles
%			\item Longer blocks for "frogger" to hop onto
%			\item 
%		\end{itemize}
%	\item 2-Player Mode
%\end{itemize}

%SECTION 3 - Block Diagram - 
\section{Block Diagram} 
\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\textwidth]{Block_Diagram.png}
	\caption{Top Block Diagram}
	\label{fig:moving-state}
\end{figure}
 
 
%SECTION 4 - Purpose of Modules - 
\section{Purpose of Modules}
	%ERIC SECTION/RYAN SECTION- WORK ON YOUR RESPECTIVE STUFF
	
	\subsection{final\_frogger\_top}
	This is the top level module that both initializes all modules to use in the game and initializes their parameters. Three frogs are initialized and depending on the button the user presses (either 1, 2, or 3 on the numpad) either one is active at a single instant. Both cars and lilypads are initialized using parameter constant arrays, as shown in Figure \ref{fig:car-parameters} and Figure \ref{fig:lilypad-parameters]}. 
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.45\textwidth]{car_parameters.png}
		\caption{Car Parameters}
		\label{fig:car-parameters}
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.45\textwidth]{lilypad_parameters.png}
		\caption{Lilypad Parameters}
		\label{fig:lilypad-parameters]}
	\end{figure}
	
	\subsection{Color\_Mapper}

	\begin{figure}[H]
		\centering
		\includegraphics[width=0.45\textwidth]{color_mapper_io.png}
		\caption{Color\_mapper.sv input/output.}
		\label{fig:color_mapper_io}
	\end{figure}
	
	The Color\_Mapper module is the heart of controlling what gets displayed onto the screen.  The module was inspired by Lab 8 with the moving ball sprite.  This version of Color\_Mapper has several jobs including knowing the position of and displaying all 39 sprites for the game at any given instance, establishing the proper orientation of Frogger, displaying the game clock, number of lives, and game title, as well as properly layering the background to the back of the game.  Figure \ref{fig:color_mapper_io} is a view of the inputs and outputs of the module showing just how involved this module really is to the Frogger game.  	\\
	
	The sprite generation will be discussed in full detail in "Section XII - Color and Sprite Generation".  Though it is worth noting how the background was implemented with so many sprites on the screen.  A large if-else statement was used to control the layers on the screen with front layers appearing earlier in the if-else logic and background layers appearing as the else statement.  Figure \ref{fig:background_ex} shows only the first background layer of the else condition, the blue color of the water meant to be displayed behind all lilypad sprites.     
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.45\textwidth]{background_ex.png}
		\caption{Generating a background image.}
		\label{fig:background_ex}
	\end{figure}
	
	The two variables DrawX and DrawY represent the given pixel that is to be colored in.  The two variables run through the if-else logic until they find conditions in which they satisfy.  For the example shown in Figure \ref{fig:background_ex}, any uncolored pixels left with Y coordinates between 80 and 239 inclusive are filled with the RGB value within the else if statement.  
	
	
	
	\subsection{frog}
	The frog module contains the logic for the moving component controlled by the user (the ``frog"). This entails the logic for what the frog does when detecting it is colliding with a car, a lilypad, water, or the end position. The frog state diagram is explained below in the "Finite State Machines" section. 
	
	This module takes inputs as the desired start position of the frog, the controller keys (up, down, left, right), lilypad collision signals, car collision signals, and lilypad parameters (so it can sync up with the movements of the lilypad). The module outputs the frog x and y position to display on the screen.
	
	\subsection{car}
	The car module contains the logic for the moving cars in the bottom half of the screen. This module also detects if there is a collision between its location and the location of the frog. It takes input of the desired speed/direction and updates/outputs the position of the car to display on the screen. It also takes inputs of the frog x and y position so it can determine if the car is collided with the frog. If it is, then it outputs a collision signal.
	
	The logic for the collision detection is shown in Figure \ref{fig:car-collision}.
	

	\subsection{car\_row}
	The car\_row module uses a generate block to create four car modules and depending on the number of cars used, it updates the collision signal. It takes inputs as the number of cars, speed/direction of cars, and the gap size in between each car. It uses this information inside of a for loop to always generate four car modules, however depending on the number of cars it uses, it allows the car to collide with them. This is shown in Figure \ref{fig:car-row-generation}
	
	
	\subsection{lilypad}
	The lilypad module is similar to the functionality of the car module. This module contains the logic for the moving lilypads in the top half of the screen. It takes inputs of the desired direction/speed along with the frog x and y position and outputs the new location of the lilypad to draw to the screen. The frog x and y position are used to determine if a collision is occuring between the frog and the lilypad. This will output a collision signal if so. \\
	
	Lilypads differ from cars in that they ``carry" the frog once the two objects collide. This means that there must be a method to ``sync" up the movements of both the lilypad and the frog once they collide. For this reason, the lilypad module also must output its remaining count on its state machine cycle for its speed. This is so that if the frog lands on the lilypad midway through its ``move" cycle, then the frog can essentially take over the count of the lilypad and be synced up and move accordingly.
	
	\subsection{lilypad\_row}
	The lilypad\_row module is similar to that of the car\_row module. This module takes inputs as the number of cars, speed/direction of cars, and the gap size in between each car. It uses this information inside of a for-loop to always generate four lilypad modules, however depending on the number of lilypads it only allows the frog to collide with those.
	
	\subsection{game\_logic}
	Module game\_logic.sv controls the overall finite state machine of the Frogger game.  This module monitors number of frogs to successfully get to the other side of the screen.  It then sends the game into a win or death state depending on the outcome of the game.  This module also controls the value of the game clock.  If the game clock runs out of time before the three frogs reach the other side, the game ends and the player loses. 
	
	\subsection{hpi\_io\_intf}
	This method takes HPI output values from the NIOS II as input, checks for a call to reset, and if no reset, assigns these values to the proper values to be outputted by the top-level module to the CY7C67200 chip.  Inputs and outputs used are shown below. 
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.45\textwidth]{hpiio.jpg}
		\label{fig:hpiio}
	\end{figure}
	
	\subsection{VGA\_controller}
	The VGA\_controller manages output to the monitor.  Inputs include clock and reset. Outputs include several sync signals, a pixel clock specified for 25 MHz and 10 bit horizontal and vertical coordinate signals as shown below.
	


	
%SECTION 5 - Circuit Schematics - 
\section{Circuit Schematics}
Due to the complexity of the project, the circuit schematic cannot be adequately displayed inside of this report. Please refer to the System Verilog code for more information regarding the schematic.



%SECTION 6 - Finite State Machines - 
\section{Finite State Machines}
There were a total of 3 FSMs implemented in Frogger. One for the user-controlled component (the frog), another for the moving components (cars and lilypads), and the last for the game logic.\\ 

The frog module state diagram controls what happens to frogger when a particular action occurs. For example, if frogger collides with a car or water, it must die. However, if frogger collides with a lilypad, it must move at the same rate as the lilypad. These state machines are shown in Figures \ref{fig:frogger-state}, \ref{fig:game-logic-state-diagram}, and \ref{fig:moving-state}.


%SECTION 7 - Color and Sprite Generation
\section{Color \& Sprite Generation}
A total of 39 sprites appear on the VGA monitor at any given moment.  They consist of three (3) frogs, sixteen (16) lilypads, eight (8) cars facing to the left, eight (8) cars facing to the right, two (2) digits for representing the tens digit and ones digit of the game clock, (1) digit for representing the number of lives left, and (1) sprite for the logo image.  \\

The logo is the least complex displaying a static picture of the game logo, while the frogs are the most complex sprites controlling both location and orientation. The cars and lilypads were complex in their own way since there were multiple sprites on multiple rows that needed position to be tracked.  Let's look at the process used to get carright\_sprite from the drawing board to the big screen as an example. 

	\begin{figure}[H]
		\centering
		\includegraphics[width=0.45\textwidth]{piskel.png}
		\caption{Generating carright\_sprite in Piskel.}
		\label{fig:piskel}
	\end{figure}  

All sprites were born as .png files for clear, simple pixel mappings.  It was not as easy as finding .png files from the internet or converting our own images into .png files, however.  Even the clearest .png files had thousands of colors due to poor clarity.  Developing sprites thus began with Piskel, a free online sprite editor, which allowed us to optimize for the minimal amount of color use.  Figure \ref{fig:piskel} shows the creation of carright\_sprite in Piskel.  A Java file was used to generate all sprite files for the game mapping each pixel to a color. A palette, or array of colors used amongst all sprites, was also generated based on all sprites used in the project.  This process made it easy to map the correct color from the palette.sv to the sprite generation file in the Color\_Mapper module.

	\begin{figure}[H]
		\centering
		\includegraphics[width=0.45\textwidth]{sprite_description1.png}
		\caption{Grabbing inputs for rightcar\_sprite.}
		\label{fig:sprite_description1}
	\end{figure} 

The Color\_Mapper module takes five parts to properly map one of the carright\_sprite(s) onto the screen. It first inputs the x and y location for each car\_row as well as generates variables such as car\_on1 to check if a car is on at a given pixel. Figure \ref{fig:sprite_description1} shows a screenshot of these lines of code.  The carright\_sprite was only generated on rows 1 and 3, so those are the only rows cared about for this example.


	\begin{figure}[H]
		\centering
		\includegraphics[width=0.45\textwidth]{sprite_description2.png}
		\caption{Determining location of cars in first car row.}
		\label{fig:sprite_description2}
	\end{figure} 

Next four cars are mapped onto their given rows.  In Figure \ref{fig:sprite_description2} we see the first car row get mapped.  Pixels specified by DrawX and DrawY values are given a specific car\_on1 value, 1 if a car is at that pixel and 0 if there is no car at that pixel.  \\

The third part of Color\_Mapper initializes the sprite 2D pixel array as well as the palette.  The palette only gets initialized once for all sprites.  A color index, x and y index are also initialized here.  Figure \ref{fig:sprite_description3} shows this part for the carright\_sprite.            

 	\begin{figure}[H]
 		\centering
 		\includegraphics[width=0.45\textwidth]{sprite_description3.png}
 		\caption{Initializing variables for sprites.}
 		\label{fig:sprite_description3}
 	\end{figure} 

Following this, each car gets its upper left-hand corner (x,y) positioned marked.  For this example, the first car in the first row is used.  Car2X and Car2Y were designated to point to upper left-hand corner coordinates of this carright\_sprite. Variables rightcar\_x\_index and rightcar\_y\_index are assigned to be the local x and y index within the sprite.  These values are then used to map the proper color value at each pixel location to rightcar\_color\_idx.   
	
 	\begin{figure}[H]
 		\centering
 		\includegraphics[width=0.45\textwidth]{sprite_description4.png}
 		\caption{Mapping the carright\_sprite to its color index.}
 		\label{fig:sprite_description4}
 	\end{figure}	

	
The fifth stage within Color\_Mapper is to finally draw the sprite to the screen.  A large if statement checks for DrawX and DrawY values to contain car\_on values.  This means the car exists at that pixel and it can be mapped to its proper color in the sprite.  Figure \ref{fig:sprite_description5} shows this being done for the carright\_sprite.  The RGB values are properly mapped to the correct values for the pixel and outputted from Color\_Mapper to the VGA\_controller to be displayed onto the VGA monitor. 


	\begin{figure}[H]
		\centering
		\includegraphics[width=0.45\textwidth]{sprite_description5.png}
		\caption{Establishing RGB for each pixel in carright\_sprite.}
		\label{fig:sprite_description5}
	\end{figure}	
	
Every sprite that moved went through these five stages in the  Color\_Mapper module in order to be displayed.  The game clock, lives counter, and game logo could bypass the first two stages since their position on the screen remained static.  The game clock and lives counter required inputs to the Color\_Mapper module to declare which number to display on the screen. \\

One last added feature not mentioned was the ability to control the direction of the frogs.  A direction variable was used to record the last direction key used on the frog and orient the frog based on that direction.  Matrix transformations were then used to rotate the 2D pixel array of the frog to the proper direction.  \\  	
	
%SECTION 8 - Difficulty 
\section{ Difficulty}
	%RYAN SECTION - Make an argument for the difficulty of this project
Producing the Frogger game in less than five weeks was no simple task.  The team came across a number of issues on a range of the features that were implemented into the game.  Most of the problems encountered came about from dealing with the System Verilog software.  What would be a simple function in a high-level programming language became rather tedious in System Verilog and required some thought in order to successfully implement.  \\


	\begin{figure}[H]
		\centering
		\includegraphics[width=0.45\textwidth]{sprite_description5.png}
		\caption{Establishing RGB for each pixel in carright\_sprite.}
		\label{fig:sprite_description5}
	\end{figure}	
	
Every sprite that moved went through these five stages in the  Color\_Mapper module in order to be displayed.  The game clock, lives counter, and game logo could bypass the first two stages since their position on the screen remained static.  The game clock and lives counter required inputs to the Color\_Mapper module to declare which number to display on the screen. \\

One last added feature not mentioned was the ability to control the direction of the frogs.  A direction variable was used to record the last direction key used on the frog and orient the frog based on that direction.  Matrix transformations were then used to rotate the 2D pixel array of the frog to the proper direction.  \\  	
	

%SECTION 9 - Conclusion
\section{Conclusion} '
\begin{table}[htbp]
	\centering
	\begin{tabular}{c|c}	% ccccccc indicates 7 center aligned columns
		\toprule	% top separator
		Resource & Value \\
		\midrule
		LUT & 9239\\
		DSP & 0\\
		Memory (BRAM) & 82,944\\
		Flip-Flop & 656\\
		Frequency &  73.32 MHz\\
		Static Power & 102.66 mW\\
		Dynamic Power & 50.68 mW\\
		Total Power & 249.76 mW\\
		\bottomrule	% bottom separator
	\end{tabular}%	
	\caption{Design Statistics}
	\label{tab:design}
\end{table}

Table \ref{tab:design} displays the design statistics for this project. 

Producing the Frogger game in less than five weeks was no simple task.  The team came across a number of issues on a range of the features that were implemented into the game.  Most of the problems encountered came about from dealing with the System Verilog software.  What would be a simple function in a high-level programming language became rather tedious in System Verilog and required some thought in order to successfully implement.  \\

One of the most difficult tasks in making the game was collision control for the Frogger sprite with obstacles, particularly with the lily pads.  The algorithm for collision control turned into a long if statement containing many AND/OR conditions for the cars touching the frog x and y position.  Collision for the frog with the cars was easy once that long statement was put into place and modified for precision.  It was easy because a simple contact between the frog sprite and car sprite killed the frog and ended the game.  Creating collision control with the lily pads was far more difficult to implement.  The frog should land on the lily pad and live, floating across the screen holding its position fixed to the lily pad until another direction key is pressed.  Clock issues came into play when trying to match up the speeds of the two colliding sprites, especially when the two sprites have different initial speeds. This was solved after a couple days of debugging in simulations.  \\

Another issue was generating the high level graphics for the sprites and background.  The on-chip memory alone was not enough to hold the amount of colors and pixels of all graphics desired for the project. When attempting to compile a very detailed background, this was seemingly stuck on synthesizing the background for ROM and took too long of a time. In order to get a more complex background implemented, the SDRAM neded to be utilized. However, due to time restrictions, the team decided to simplify the color palette instead of using the SDRAM.

This project overall was a very difficult project to implement in terms of collision control and color mapping. Initially the team was going to say that this project is a 3 or 4 in terms of difficulty, however upon actual implementation, this project is upwards of 6 or 7. Programming frogger in hardware/system verilog proved to be a very difficult, yet rewarding task. 



\clearpage
\onecolumn
%SECTION 10: Figures & Appendix
\section{Figures}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{starting_screen.png}
	\caption{Starting Screen}
	\label{fig:starting-screen}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{car_collision.png}
	\caption{Car Collision Logic}
	\label{fig:car-collision}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{lilypad_collision.png}
	\caption{Lilypad Collision Logic}
	\label{fig:lilypad-collision}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{car_row_generation.png}
	\caption{Car Row Generation}
	\label{fig:car-row-generation}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{lpad_row_generation.png}
	\caption{Lilypad Row Generation}
	\label{fig:lpad-row-generation}
\end{figure}


\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{frogger_state_diagram.png}
	\caption{Frogger State Diagram}
	\label{fig:frogger-state}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{game_logic_state_diagram.png}
	\caption{Game Logic State Diagram}
	\label{fig:game-logic-state-diagram}

\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{moving_state.png}
	\caption{Moving Obstacles State Diagram}
	\label{fig:moving-state}
\end{figure}


\section*{Appendix}




%%\begin{figure} [H]
%%	\centering
%%	\includegraphics[scale=.3]{Frogger.png}
%%	\caption{Basic Gameplay Demonstration\label{fig:frogger}}
%%\end{figure}            
%
%     

\end{document}
