% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% IEEE Style - Double columns, 11pt font, letterpaper
\documentclass[journal, twocolumn, final,11pt,letterpaper]{IEEEtran}	

% Include Latex Packages
\input{header.tex}


% Title of Document
\title{ECE385 Experiment \#9
	}
\author{
\IEEEauthorblockN{Eric Meyers, Ryan Helsdingen}\\
\IEEEauthorblockA{Section ABG; TAs: Ben Delay, Shuo Liu \\
April 13th, 2016 \\
emeyer7, helsdin2}}
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
\begin{document}
	
%SECTION : Formatting and Title
\maketitle
\singlespacing

%SECTION 1 - Introduction - Eric
\section{Introduction}
The purpose of this lab was to explore encryption/decryption techniques using the Advanced Encryption Standard (AES). The team wrote both encryption and decryption algorithms that runs on software and hardware respectively. The advantages/disadvantage of these two techniques will be analyzed in the post-lab section. 

%SECTION 2 - Description of Circuit / Inputs and Outputs - 
\section{Description of Circuit}
The encryption algorithm will be performed on a NIOS-II processor and programmed in C, whereas the decryption algorithm will be performed on a Cyclone IV FPGA and programmed in System Verilog. \\

The C program onboard the NIOS-II processor  will communicate with the hardware on the Altera DE2-115 board and transfer both the encrypted message and key to the hardware. The hardware will then proceed to decrypt this message using the provided key and display the result on the hex display.

%SECTION 3 - Purpose of Modules - 
\section{Purpose of Modules}
The AES encryption/decryption algorithm used several modules. However, these can be broken down into software modules and hardware modules. The only software module was the NIOS system used to create the software encryption algorithm in C. The following were the hardware modules and these will be explained in detail when necessary:
\begin{itemize}
	\item lab9 (top-level)
	\item aes\_controller
	\item AES
	\item io\_module
	\item KeyExpansion
	\item AddRoundKey
	\item SubBytes, InvSubBytes
	\item InvSubBytes\_16
	\item ShiftRows, InvShiftRows
	\item MixColumns, InvMixColumns
	\item HexDriver
\end{itemize}

First, the encryption algorithm, as stated before was programmed in C on a NIOS-II processor. This processor is contained within the "NIOS system". \\

The NIOS system developed was similar to that of the one created in lab8 except there are 4 PIO modules to allow communication to/from the hardware (to\_sw\_sig, to\_hw\_sig, to\_sw\_port, to\_hw\_port). A JTAG UART peripheral was used to allow debugging upon the host computer and to allow user input to the C program. \\

\textit{lab9}\\
\vspace{-4mm}

This is the top-level module containing the connections from the nios\_system, aes\_controller, io\_module, and the hex display. \\

\textit{aes\_controller}\\
\vspace{-4mm}

The aes\_controller is the module that controls the operation of the AES module. It determines if the AES decryption algorithm is in a IDLE state, COMPUTE state, or READY state. This is accomplished through a simple state machine that was provided. The only changes the team made is instead of relying on a counter to determine when the algorithm was done, this was instead done inside the algorithm itself and output through the module into the controller.\\

\textit{AES}\\
\vspace{-4mm}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.45\textwidth]{AES.jpg}
	\label{fig:AES}
\end{figure}

The AES module is the main decryption algorithm implementation. It contains inputs of Reset and Run, along with 128-bits of encrypted text and 128-bits of a key. It outputs a 128-bit value containing the plaintext of the encrypted input after finishing. The main algorithm is explained in the lab manual, as well as below in the State Diagram section. \\

The module essentially loops through 10 rounds of calculations with each round containing the correct cycle of calculations as defined by the state machine. \\

\textit{io\_module}\\
\vspace{-4mm}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.45\textwidth]{iomodule.jpg}
	\label{fig:iomodule}
\end{figure}

The io\_module provides the communication between the hardware and software.  The module follows a 100-state machine diagram shown in Figure \ref{fig:io-module}. Inputs include the decrypted message, hardware port and sig signals to control the movement of the message, clock, reset, and AES ready bit.  Outputs include 128-bit encrypted messaage and key, software port and sig signals, IO ready bit, and output signals to show the state number on the LEDs. \\

\textit{KeyExpansion}\\
\vspace{-4mm}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.45\textwidth]{KeyExpansion.jpg}
	\label{fig:KeyExpansion}
\end{figure}

The KeyExpansion module takes in the Cipher Key to create the first round key and then loops 10 more times creating 128-bit Round Keys each based off the previous key.  The 11 Round Keys are then stored into a 1408-bit Key Schedule. \\  

\textit{AddRoundKey}\\
\vspace{-4mm}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.45\textwidth]{AddRoundKey.jpg}
	\label{fig:AddRoundKey}
\end{figure}

The AddRoundKey module fetches a 4-word, 128-bit Round key from the pre-computed Key Schedule and bitwise XORs with the corresponding byte from the updating 128-bit state.  \ref{fig:AddRoundKeydia} shows a diagram of the AddRoundKey module. \\

\begin{figure}[h]
	\centering
	\includegraphics[width=0.45\textwidth]{AddRoundKeydia.jpg}
	\label{fig:AddRoundKeydia}
\end{figure}  


\textit{SubBytes,InvSubBytes}\\
\vspace{-4mm}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.45\textwidth]{SubBytes.jpg}
	\label{fig:SubBytes}
\end{figure}

SubBytes takes each byte of the updating state and transforms it by taking the multiplicative inverse of the Rijindael's finite field.  The transformation has been simplified into a black-box designated as the S-box (substitution box).  Inputs include the 256 byte array and clock.  Outputs include the transformed 256 byte array. Figure \ref{fig:SubBytesdia} portrays this module as a 4x4 matrix for sample.  \\

\begin{figure}[h]
	\centering
	\includegraphics[width=0.45\textwidth]{SubBytesdia.jpg}
	\label{fig:SubBytesdia}
\end{figure}

The InvSubBytes module is similar to the SubBytes module except that the S-box is replaced by its inverse to reverse the encryption process.  \\

\textit{InvSubBytes\_16}\\
\vspace{-4mm}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.45\textwidth]{InvSubBytes_16.jpg}
	\label{fig:InvSubBytes_16}
\end{figure}


InvSubBytes\_16 is a submodule of InvSubBytes.  It takes in the entire state during the InvSubBytes round and performs the appropriate substitution for each row and column. \\

\textit{ShiftRows,InvShiftRows}\\
\vspace{-4mm}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.45\textwidth]{InvShiftRows.jpg}
	\label{fig:InvShiftRows}
\end{figure}

The ShiftRows module takes in the 128-bit state and shifts the elements in each row n of the matrix by n-1 to the left.  Figure \ref{fig:InvShiftRows} shows a diagram of ShiftRows. \\ 

\begin{figure}[h]
	\centering
	\includegraphics[width=0.45\textwidth]{ShiftRowsdia.jpg}
	\label{fig:ShiftRowsdia}
\end{figure}

The InvShiftRows module does exactly whatt he ShiftRows module does except it reverses the direction such the row n is right-circularly shifted by n-1 times. 

\textit{MixColumns,InvMixColumns}\\
\vspace{-4mm}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.45\textwidth]{InvMixColumns.jpg}
	\label{fig:InvMixColumns}
\end{figure}

The MixColumns module takes each of the four words from the state individually and goes through invertible linear tranformations over GF($2^8$) including multiplication by a fixed polynomial matrix to linearly combine the four bytes of each word to form a new Word.\\

\textit{HexDriver}\\
\vspace{-4mm}

This module contains the logic necessary to output values in binary/decimal in hex on the hex displays on board the Altera De2-115.\\


%SECTION 4 - Description of USB Protocol & Changes
\section{Software/Hardware State Diagram}
The software/hardware state diagram is handled in io\_module and is shown in Figure \ref{fig:io-module}.

%SECTION 5 - State Diagram for Decryption 
\section{Decryption State Diagram}
The decryption state diagram is split up into two FSMs for simplicity. One is referred to as the Calculation FSM and the other is referred to as the Round FSM. There are a total of 10 rounds with an extra round to ensure the key\_expansion algorithm performs. Each round a series of calculations are performed as determined in the algorithm outlined in the description PDF of this lab. The Round FSM is shown in Figure \ref{fig:round-state} and the Calculation FSM is shown in Figure \ref{fig:calc-state}.

%SECTION 6 - Schematic/Block Diagram
\section{Schematic/Block Diagram}

%SECTION 7 - Annotated Pre-Lab Waveforms
\section{Annotated Pre-Lab Waveforms}
The annotated pre-lab waveforms can be found in Figure \ref{fig:0-500}, \ref{fig:500-1000}, \ref{fig:1000-1500}, and \ref{fig:1500-2000} for a 2000ns period. The ending decrypted value given plaintext of "daec3055df058e1c39e814ea76f6747e" with a key of "0102030405060708090a0b0c0d0e0f" is "ece298ece298...dc".

%SECTION 8 - Post Lab - 
\section{Post Lab}
\begin{table}[htbp]
	\centering
	\begin{tabular}{c|c}	% ccccccc indicates 7 center aligned columns
		\toprule	% top separator
		Resource & Value \\
		\midrule
		LUT & \\
		DSP & \\
		Memory (BRAM) & \\
		Flip-Flop & \\
		Frequency &  MHz\\
		Static Power &  mW\\
		Dynamic Power & mW\\
		Total Power & mW\\
		\bottomrule	% bottom separator
	\end{tabular}%	
	\caption{Design Statistics}
	\label{tab:design}
\end{table}

\begin{enumerate}
	\item Which would you expect to be faster to complete encryption/decryption, the software or hardware? Is this what your results show?
	\begin{itemize}
		\item The faster encryption/decryption is expected to be the hardware because programming in software (specifically in C) is meant for generalized processors and thus must go through more clock cycles to do more compared to that of the hardware. The hardware is dedicated to the task at hand, and thus is faster than the software. \\
		
			\setlength{\leftskip}{24pt}Software Speed: MB/s \\
			Hardware Speed: MB/s (simulation)\\
			
	\end{itemize}
	\item If you wanted to speed up the hardware, what would you do? (Note: restrictions of this lab do not apply to answer this question)
	\begin{itemize}
		\item Instead of containing separate modules for each of the operations, these can be combined into a single module and the entire computation for one round can be done in a single state. This would significantly decrease the amount of time taken for one state to process. 
	\end{itemize}
\end{enumerate}


%SECTION 9 - Conclusion
\section{Conclusion}
Overall, this lab proved to be very difficult from both a hardware and software perspective. Programming the encryption algorithm in C was difficult for many reasons. Working with two-dimensional arrays is never an easy task in C, and this lab seemed to put this skill to the test. The notation used throughout the algorithm is difficult to understand fully what should be passed into certain functions. However, once a basic working model of the encryption algorithm was developed, it was optimized for patterns, and condensed and therefore much easier to understand. \\

The hardware decryption was just as difficult as the software. The finite state machines that were developed took a large amount of time to debug using ModelSim. The io\_module used to pass information to/from the software proved to be a large time-sing in and of itself. \\

In the end, the team did not receive full points for demo due to a glitch in passing the data to/from software. However, partial credit was received for showing simulations...\\

Overall this lab was one of the most difficult ECE385 labs, however it was one of the most rewarding to understand in the end. AES encryption/decryption is now very clear to the team.

\clearpage
\onecolumn
%SECTION 10: Figures
\section{Figures}


\begin{figure} [H]
	\centering
	\includegraphics[scale=.6]{IO_Module_State_Diagram.png}
	\caption{IO Module Hardware/Software State Diagram\label{fig:io-module}}
\end{figure}  


\begin{figure} [H]
	\centering
	\includegraphics[scale=.6]{Decryption_Round_State_Diagram.pdf}
	\caption{Decryption Round State Diagram\label{fig:round-state}}
\end{figure}          

\begin{figure} [H]
	\centering
	\includegraphics[scale=.6]{Calc_State_Diagram.png}
	\caption{Calculation State Diagram\label{fig:calc-state}}
\end{figure}         


\begin{figure} [H]
	\centering
%	\includegraphics[scale=.6]{/*BLOCK*/}
	\caption{Calculation State Diagram\label{fig:calc-state}}
\end{figure}    



\begin{figure} [H]
	\centering
	\includegraphics[scale=.35]{simulate-0-500.png}
	\caption{Simulation 0 - 500ns\label{fig:0-500}}
\end{figure}          


\begin{figure} [H]
	\centering
	\includegraphics[scale=.35]{simulate-500-1000.png}
	\caption{Simulation 500 - 1000ns\label{fig:500-1000}}
\end{figure}          


\begin{figure} [H]
	\centering
	\includegraphics[scale=.35]{simulate-1000-1500.png}
	\caption{Simulation 1000 - 1500ns\label{fig:1000-1500}}
\end{figure}          


\begin{figure} [H]
	\centering
	\includegraphics[scale=.35]{simulate-1500-2000.png}
	\caption{Simulation 1500-2000ns\label{fig:1500-2000}}
\end{figure}          


     

\section*{Appendix}
%\begin{lstlisting}
%void IO_write(alt_u8 Address, alt_u16 Data)
%{
%
%}
%\end{lstlisting}

\end{document}
